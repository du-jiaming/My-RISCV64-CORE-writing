;buildInfoPackage: chisel3, version: 3.4.3, scalaVersion: 2.12.12, sbtVersion: 1.3.10
circuit DecoupledGcd : 
  module DecoupledGcd : 
    input clock : Clock
    input reset : UInt<1>
    input input : {flip ready : UInt<1>, valid : UInt<1>, bits : {value1 : UInt<16>, value2 : UInt<16>}}
    output output : {flip ready : UInt<1>, valid : UInt<1>, bits : {value1 : UInt<16>, value2 : UInt<16>, gcd : UInt<16>}}
    
    reg xInitial : UInt, clock @[DecoupledGCD.scala 26:24]
    reg yInitial : UInt, clock @[DecoupledGCD.scala 27:24]
    reg x : UInt, clock @[DecoupledGCD.scala 28:24]
    reg y : UInt, clock @[DecoupledGCD.scala 29:24]
    reg busy : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[DecoupledGCD.scala 30:28]
    reg resultValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[DecoupledGCD.scala 31:28]
    node _input_ready_T = eq(busy, UInt<1>("h00")) @[DecoupledGCD.scala 33:19]
    input.ready <= _input_ready_T @[DecoupledGCD.scala 33:16]
    output.valid <= resultValid @[DecoupledGCD.scala 34:16]
    output.bits.gcd is invalid @[DecoupledGCD.scala 35:16]
    output.bits.value2 is invalid @[DecoupledGCD.scala 35:16]
    output.bits.value1 is invalid @[DecoupledGCD.scala 35:16]
    when busy : @[DecoupledGCD.scala 37:14]
      node _T = gt(x, y) @[DecoupledGCD.scala 38:12]
      when _T : @[DecoupledGCD.scala 38:17]
        node _x_T = sub(x, y) @[DecoupledGCD.scala 39:14]
        node _x_T_1 = tail(_x_T, 1) @[DecoupledGCD.scala 39:14]
        x <= _x_T_1 @[DecoupledGCD.scala 39:9]
        skip @[DecoupledGCD.scala 38:17]
      else : @[DecoupledGCD.scala 40:17]
        node _y_T = sub(y, x) @[DecoupledGCD.scala 41:14]
        node _y_T_1 = tail(_y_T, 1) @[DecoupledGCD.scala 41:14]
        y <= _y_T_1 @[DecoupledGCD.scala 41:9]
        skip @[DecoupledGCD.scala 40:17]
      node _T_1 = eq(x, UInt<1>("h00")) @[DecoupledGCD.scala 43:12]
      node _T_2 = eq(y, UInt<1>("h00")) @[DecoupledGCD.scala 43:25]
      node _T_3 = or(_T_1, _T_2) @[DecoupledGCD.scala 43:20]
      when _T_3 : @[DecoupledGCD.scala 43:34]
        node _T_4 = eq(x, UInt<1>("h00")) @[DecoupledGCD.scala 44:14]
        when _T_4 : @[DecoupledGCD.scala 44:23]
          output.bits.gcd <= y @[DecoupledGCD.scala 45:25]
          skip @[DecoupledGCD.scala 44:23]
        else : @[DecoupledGCD.scala 46:19]
          output.bits.gcd <= x @[DecoupledGCD.scala 47:25]
          skip @[DecoupledGCD.scala 46:19]
        output.bits.value1 <= xInitial @[DecoupledGCD.scala 50:26]
        output.bits.value2 <= yInitial @[DecoupledGCD.scala 51:26]
        resultValid <= UInt<1>("h01") @[DecoupledGCD.scala 52:26]
        node _T_5 = and(output.ready, resultValid) @[DecoupledGCD.scala 54:25]
        when _T_5 : @[DecoupledGCD.scala 54:41]
          busy <= UInt<1>("h00") @[DecoupledGCD.scala 55:21]
          resultValid <= UInt<1>("h00") @[DecoupledGCD.scala 56:21]
          skip @[DecoupledGCD.scala 54:41]
        skip @[DecoupledGCD.scala 43:34]
      skip @[DecoupledGCD.scala 37:14]
    else : @[DecoupledGCD.scala 59:15]
      when input.valid : @[DecoupledGCD.scala 60:23]
        input.ready <= UInt<1>("h01") @[Decoupled.scala 65:20]
        x <= input.bits.value1 @[DecoupledGCD.scala 62:16]
        y <= input.bits.value2 @[DecoupledGCD.scala 63:16]
        xInitial <= input.bits.value1 @[DecoupledGCD.scala 64:16]
        yInitial <= input.bits.value2 @[DecoupledGCD.scala 65:16]
        busy <= UInt<1>("h01") @[DecoupledGCD.scala 66:16]
        skip @[DecoupledGCD.scala 60:23]
      skip @[DecoupledGCD.scala 59:15]
    
